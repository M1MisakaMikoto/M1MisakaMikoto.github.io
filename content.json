{"meta":{"title":"M1MisakaMikoto's Blog","subtitle":"Powered on Hexo","description":"","author":"M1MisakaMikoto","url":"http://M1MisakaMikoto.github.io","root":"/"},"pages":[],"posts":[{"title":"位运算符的妙用vol.1","slug":"位运算符的妙用vol-1","date":"2023-10-31T13:25:03.000Z","updated":"2023-10-31T15:38:30.312Z","comments":true,"path":"2023/10/31/位运算符的妙用vol-1/","link":"","permalink":"http://m1misakamikoto.github.io/2023/10/31/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%A6%99%E7%94%A8vol-1/","excerpt":"","text":"位运算符的妙用vol.1&lt;&lt;左移运算符代替乘法先放定义：左移运算符是一个C++中的一种位操作符。用来将一个数的各二进制位全部左移若干位，移动的位数由右操作数指定，右操作数必须是非负值，其右边空出的位用0填补，高位左移溢出则舍弃该高位 举个栗子一是进制数 9 转为二进制是 0000 1001对 0000 1001 进行左移一位的操作后得到 0001 00100001 0010 对应的数就是 18 为什么有这样的规律？将二进制数x2 可以看做对每一位二进制数字x2若该位数字是 0, x2后无变化若该位数字是 1, x2后变为 10最终该数在形式上的变化就是左移了一位 优势运算速度比乘法更快 运算消耗更少 &gt;&gt;右移运算符代替除法同上 |或运算符将偶数+1举个栗子2 | 1 = 3why?:十进制偶数 2 对应二进制数 0010十进制偶数 4 对应二进制数 0100十进制偶数 6 对应二进制数 0110十进制偶数 8 对应二进制数 1000十进制偶数对应的二进制数的个一定是 00 与 1 进行或运算结果是 1反映在十进制数中就是将偶数+1变为奇数 &amp;与运算符将奇数-1举个栗子3 &amp; 0 = 2why?:与或运算符将偶数+1原理类似","categories":[{"name":"CS","slug":"CS","permalink":"http://m1misakamikoto.github.io/categories/CS/"}],"tags":[]},{"title":"前缀和","slug":"前缀和","date":"2023-10-30T13:34:29.000Z","updated":"2023-10-30T14:36:33.162Z","comments":true,"path":"2023/10/30/前缀和/","link":"","permalink":"http://m1misakamikoto.github.io/2023/10/30/%E5%89%8D%E7%BC%80%E5%92%8C/","excerpt":"","text":"前缀和例题输入一个长度为的整数序列，接下来再输入个询问，每个询问输入一对, （左边界和右边界[, ]） 对于每个询问，输出原序列中从第l个数到第r个数的和。 输入格式第一行包含两个整数和。第二行包含个整数，表示整数数列。接下来行，每行包含两个整数和，表示一个询问的区间范围。 输出格式共行，每行输出一个询问的结果。数据范围1≤≤≤,1≤,≤100000,−1000≤数列中元素的值≤1000 输入样例：123455 32 1 3 6 41 21 32 4 输出样例：1233610 前缀和数组举个例子，假设现在有一数组int a[7] = {1,2,3,4,5,6,7}第一位的前缀和就是a[0], 第二位的前缀和就是a[0] + a[1], 以此类推第n位的前缀和就是a[0] + a[1] + … + a[n-1]由此可得一个前缀和数组int frontSUM = {0,1,3,6,10,15,21,28}若此时要求某个区间内[x, y]值的和，那么这个和就等于frontSUM[y] - frontSUM[x - 1]但由于x - 1可能为负值，因此将前缀和数组的第一位设为0 创建前缀和数组引用上述案例的2 1 3 6 4由于frontSUM[n] = frontSUM[n - 1] + an - 1可得： 123456vector frontSUM(1,0);for (int i = 1; i &lt;= 5; i++) { int inputValue; cin &gt;&gt; inputValue; frontSUM.push_back(frontSUM[i - 1] + inputValue); } 测试代码： 123456789101112131415#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main() { vector&lt;int&gt; frontSUM(1,0); for (int i = 1; i &lt;= 5; i++) { int inputValue; cin &gt;&gt; inputValue; frontSUM.push_back(frontSUM[i - 1] + inputValue); } for (int i = 0; i &lt; 6; i++) { cout &lt;&lt; frontSUM[i] &lt;&lt; \" \"; }} 最终题解： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main() { int numAccount = 0; cin &gt;&gt; numAccount; int areaAccount = 0; cin &gt;&gt; areaAccount; vector&lt;int&gt; frontSUM(1,0); for (int i = 1; i &lt;= numAccount; i++) { int inputValue; cin &gt;&gt; inputValue; frontSUM.push_back(frontSUM[i - 1] + inputValue); } struct Area { int leftPoint; int rightPoint; }; vector&lt;Area&gt; areaVector; for (int i = 0; i &lt; areaAccount; i++) { Area areaTemporary; int inputValue; cin &gt;&gt; inputValue; areaTemporary.leftPoint = inputValue; cin &gt;&gt; inputValue; areaTemporary.rightPoint = inputValue; areaVector.push_back(areaTemporary); } for (int i = 0; i &lt; areaAccount; i++) { cout &lt;&lt; frontSUM[areaVector[i].rightPoint] - frontSUM[areaVector[i].leftPoint - 1] &lt;&lt; endl; } return 0;} 参考资料：csdn:前缀和【超详细讲解前缀和】","categories":[{"name":"CS","slug":"CS","permalink":"http://m1misakamikoto.github.io/categories/CS/"}],"tags":[]},{"title":"2023-10-30-LearningRecord","slug":"2023-10-30-LearningRecord","date":"2023-10-30T13:09:19.000Z","updated":"2023-11-01T04:34:35.820Z","comments":true,"path":"2023/10/30/2023-10-30-LearningRecord/","link":"","permalink":"http://m1misakamikoto.github.io/2023/10/30/2023-10-30-LearningRecord/","excerpt":"","text":"刷题Day002 题目一[NOIP2005 普及组] 校门外的树题目描述某校大门外长度为 的马路上有一排树，每两棵相邻的树之间的间隔都是 米。我们可以把马路看成一个数轴，马路的一端在数轴 的位置，另一端在 的位置；数轴上的每个整数点，即 ，都种有一棵树。 由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。 输入格式第一行有两个整数，分别表示马路的长度 和区域的数目 。 接下来 行，每行两个整数 ，表示一个区域的起始点和终止点的坐标。 输出格式输出一行一个整数，表示将这些树都移走后，马路上剩余的树木数量。 样例 #1样例输入 #11234500 3150 300100 200470 471 样例输出 #11298 提示【数据范围】 对于 的数据，保证区域之间没有重合的部分。 对于 的数据，保证 ，，。 【题目来源】 NOIP 2005 普及组第二题 解法一(状态数组)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;//用一个结构体来存储区域的范围struct Volume { int startPoint; int endPoint;};//此函数用于接受输入的数据并存入一个结构体数组 并返回树木数量int collectInput(vector&lt;Volume&gt;&amp; volume) { int Length, areaAccount, leftPoint, rightPoint; scanf(\"%d %d\", &amp;Length, &amp;areaAccount); Volume temp; for (int i = 0; i &lt; areaAccount; i++) { scanf(\"\\n%d %d\", &amp;leftPoint, &amp;rightPoint); temp.startPoint = leftPoint; temp.endPoint = rightPoint; volume.push_back(temp); } return Length + 1;}int main() { //新建一个结构体数组，用于存储要去除树的区域的左右坐标 vector&lt;Volume&gt; volume; //新建一个长度为树的棵树的bool类型数组，用下标代表坐标，true代表此处有树，false代表此处无树 vector&lt;bool&gt; statusArray; int Length = collectInput(volume); //用resize命令申请空间（此时capasity=size，不浪费内存空间） statusArray.resize(Length,true); //砍树:&lt; for (int i = 0; i &lt; volume.size(); i++) { for (int j = volume[i].startPoint; j &lt;= volume[i].endPoint; j++) { statusArray[j] = false; } } //遍历状态数组，统计剩余树的数量 int count = 0; for (int i = 0; i &lt; statusArray.size(); i++) { if (statusArray[i]) { count++; } continue; } //输出 cout &lt;&lt; count; return 0;} 解法二(线段树)：前置知识：[前缀和]前缀和","categories":[{"name":"CS","slug":"CS","permalink":"http://m1misakamikoto.github.io/categories/CS/"}],"tags":[]},{"title":"2023-10-29-LearningRecord","slug":"2023-10-29-LearningRecord","date":"2023-10-29T15:57:00.000Z","updated":"2023-11-01T04:34:43.839Z","comments":true,"path":"2023/10/29/2023-10-29-LearningRecord/","link":"","permalink":"http://m1misakamikoto.github.io/2023/10/29/2023-10-29-LearningRecord/","excerpt":"","text":"刷题Day001 题目一[NOIP2002 普及组] 级数求和题目描述已知：。显然对于任意一个整数 ，当 足够大的时候，。 现给出一个整数 ，要求计算出一个最小的 ，使得 。 输入格式一个正整数 。 输出格式一个正整数 。 样例 #1样例输入 #111 样例输出 #112 提示【数据范围】 对于 的数据，。 【题目来源】 NOIP 2002 普及组第一题 暴力解法：1234567891011int main() { int k; scanf(\"%d\", &amp;k); double SUM = 0; int n = 0; while (SUM &lt; k) { SUM += 1.0 / ++n; } cout &lt;&lt; n; return 0; } 更优的解-数论（调和级数）：▶调和级数讲解已知 欧拉推导过求调和级数有限多项和的表达式为 (约等于)因为题目要求满足的条件是 化简得 因此只需求 并向上取整即可 123456789101112#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;int main() { int k; scanf(\"%d\", &amp;k); int n = exp((double)k - 0.5772156649) + 0.5; cout &lt;&lt; n; return 0;} ps:我不知道为什么 - 1改成 +0.5然后去小数刚好是正确答案 希望有人能解答一下QAQ","categories":[{"name":"CS","slug":"CS","permalink":"http://m1misakamikoto.github.io/categories/CS/"}],"tags":[]}],"categories":[{"name":"CS","slug":"CS","permalink":"http://m1misakamikoto.github.io/categories/CS/"}],"tags":[]}