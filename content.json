{"meta":{"title":"M1MisakaMikoto's Blog","subtitle":"Powered on Hexo","description":"","author":"M1MisakaMikoto","url":"http://M1MisakaMikoto.github.io","root":"/"},"pages":[],"posts":[{"title":"2023-10-30-LearningRecord","slug":"2023-10-30-LearningRecord","date":"2023-10-30T13:09:19.000Z","updated":"2023-10-30T13:26:06.076Z","comments":true,"path":"2023/10/30/2023-10-30-LearningRecord/","link":"","permalink":"http://m1misakamikoto.github.io/2023/10/30/2023-10-30-LearningRecord/","excerpt":"","text":"var ap = new APlayer({ element: document.getElementById(\"aplayer-gpFjBnOM\"), narrow: false, autoplay: true, showlrc: false, music: { title: \"Childhood Dreams\", author: \"Gaminl\", url: \"Gaminl - Childhood Dreams.mp3\", pic: \"/2023/10/30/2023-10-30-LearningRecord/109951165264681853.jpg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 刷题Day002 题目一[NOIP2005 普及组] 校门外的树题目描述某校大门外长度为 的马路上有一排树，每两棵相邻的树之间的间隔都是 米。我们可以把马路看成一个数轴，马路的一端在数轴 的位置，另一端在 的位置；数轴上的每个整数点，即 ，都种有一棵树。 由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。 输入格式第一行有两个整数，分别表示马路的长度 和区域的数目 。 接下来 行，每行两个整数 ，表示一个区域的起始点和终止点的坐标。 输出格式输出一行一个整数，表示将这些树都移走后，马路上剩余的树木数量。 样例 #1样例输入 #11234500 3150 300100 200470 471 样例输出 #11298 提示【数据范围】 对于 的数据，保证区域之间没有重合的部分。 对于 的数据，保证 ，，。 【题目来源】 NOIP 2005 普及组第二题 解法1(状态数组)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;//用一个结构体来存储区域的范围struct Volume { int startPoint; int endPoint;};//此函数用于接受输入的数据并存入一个结构体数组 并返回树木数量int collectInput(vector&lt;Volume&gt;&amp; volume) { int Length, areaAccount, leftPoint, rightPoint; scanf(\"%d %d\", &amp;Length, &amp;areaAccount); Volume temp; for (int i = 0; i &lt; areaAccount; i++) { scanf(\"\\n%d %d\", &amp;leftPoint, &amp;rightPoint); temp.startPoint = leftPoint; temp.endPoint = rightPoint; volume.push_back(temp); } return Length + 1;}int main() { //新建一个结构体数组，用于存储要去除树的区域的左右坐标 vector&lt;Volume&gt; volume; //新建一个长度为树的棵树的bool类型数组，用下标代表坐标，true代表此处有树，false代表此处无树 vector&lt;bool&gt; statusArray; int Length = collectInput(volume); //用resize命令申请空间（此时capasity=size，不浪费内存空间） statusArray.resize(Length,true); //砍树:&lt; for (int i = 0; i &lt; volume.size(); i++) { for (int j = volume[i].startPoint; j &lt;= volume[i].endPoint; j++) { statusArray[j] = false; } } //遍历状态数组，统计剩余树的数量 int count = 0; for (int i = 0; i &lt; statusArray.size(); i++) { if (statusArray[i]) { count++; } continue; } //输出 cout &lt;&lt; count; return 0;}","categories":[{"name":"CS","slug":"CS","permalink":"http://m1misakamikoto.github.io/categories/CS/"}],"tags":[]},{"title":"2023-10-29-LearningRecord","slug":"2023-10-29-LearningRecord","date":"2023-10-29T15:57:00.000Z","updated":"2023-10-30T13:13:44.482Z","comments":true,"path":"2023/10/29/2023-10-29-LearningRecord/","link":"","permalink":"http://m1misakamikoto.github.io/2023/10/29/2023-10-29-LearningRecord/","excerpt":"","text":"var ap = new APlayer({ element: document.getElementById(\"aplayer-lByVvWDI\"), narrow: false, autoplay: true, showlrc: false, music: { title: \"All For Love\", author: \"Tungevaag & Raaban\", url: \"Tungevaag & Raaban - All For Love.mp3\", pic: \"/2023/10/29/2023-10-29-LearningRecord/109951163195963343.jpg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 刷题Day001 题目一[NOIP2002 普及组] 级数求和题目描述已知：。显然对于任意一个整数 ，当 足够大的时候，。 现给出一个整数 ，要求计算出一个最小的 ，使得 。 输入格式一个正整数 。 输出格式一个正整数 。 样例 #1样例输入 #111 样例输出 #112 提示【数据范围】 对于 的数据，。 【题目来源】 NOIP 2002 普及组第一题 暴力解法：1234567891011int main() { int k; scanf(\"%d\", &amp;k); double SUM = 0; int n = 0; while (SUM &lt; k) { SUM += 1.0 / ++n; } cout &lt;&lt; n; return 0; } 更优的解-数论（调和级数）：▶调和级数讲解已知 欧拉推导过求调和级数有限多项和的表达式为 (约等于)因为题目要求满足的条件是 化简得 因此只需求 并向上取整即可 123456789101112#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;int main() { int k; scanf(\"%d\", &amp;k); int n = exp((double)k - 0.5772156649) + 0.5; cout &lt;&lt; n; return 0;} ps:我不知道为什么 - 1改成 +0.5然后去小数刚好是正确答案 希望有人能解答一下QAQ","categories":[{"name":"CS","slug":"CS","permalink":"http://m1misakamikoto.github.io/categories/CS/"}],"tags":[]}],"categories":[{"name":"CS","slug":"CS","permalink":"http://m1misakamikoto.github.io/categories/CS/"}],"tags":[]}