{"meta":{"title":"M1MisakaMikoto's Blog","subtitle":"Powered on Hexo","description":"","author":"M1MisakaMikoto","url":"http://M1MisakaMikoto.github.io","root":"/"},"pages":[],"posts":[{"title":"2023-10-29-LearningRecord","slug":"2023-10-29-LearningRecord","date":"2023-10-30T05:43:00.000Z","updated":"2023-10-30T11:46:18.840Z","comments":true,"path":"2023/10/30/2023-10-29-LearningRecord/","link":"","permalink":"http://m1misakamikoto.github.io/2023/10/30/2023-10-29-LearningRecord/","excerpt":"","text":"刷题Day001 题目一[NOIP2002 普及组] 级数求和题目描述已知：。显然对于任意一个整数 ，当 足够大的时候，。 现给出一个整数 ，要求计算出一个最小的 ，使得 。 输入格式一个正整数 。 输出格式一个正整数 。 样例 #1样例输入 #111 样例输出 #112 提示【数据范围】 对于 的数据，。 【题目来源】 NOIP 2002 普及组第一题 暴力解法：1234567891011int main() { int k; scanf(\"%d\", &amp;k); double SUM = 0; int n = 0; while (SUM &lt; k) { SUM += 1.0 / ++n; } cout &lt;&lt; n; return 0; } 更优的解-数论（调和级数）：▶调和级数讲解已知 欧拉推导过求调和级数有限多项和的表达式为 (约等于)因为题目要求满足的条件是 化简得 因此只需求 并向上取整即可 123456789101112#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;int main() { int k; scanf(\"%d\", &amp;k); int n = exp((double)k - 0.5772156649) + 0.5; cout &lt;&lt; n; return 0;} ps:我不知道为什么 - 1改成 +0.5然后去小数刚好是正确答案 希望有人能解答一下QAQ","categories":[{"name":"Physics","slug":"Physics","permalink":"http://m1misakamikoto.github.io/categories/Physics/"}],"tags":[]}],"categories":[{"name":"Physics","slug":"Physics","permalink":"http://m1misakamikoto.github.io/categories/Physics/"}],"tags":[]}