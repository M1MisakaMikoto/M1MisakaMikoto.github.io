{"meta":{"title":"M1MisakaMikoto's Blog","subtitle":"Powered on Hexo","description":"","author":"M1MisakaMikoto","url":"http://M1MisakaMikoto.github.io","root":"/"},"pages":[],"posts":[{"title":"Dijkstra算法求最短路径","slug":"Dijkstra算法求最短路径","date":"2023-11-01T11:27:46.000Z","updated":"2023-11-01T16:33:29.163Z","comments":true,"path":"2023/11/01/Dijkstra算法求最短路径/","link":"","permalink":"http://m1misakamikoto.github.io/2023/11/01/Dijkstra%E7%AE%97%E6%B3%95%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/","excerpt":"","text":"迪杰斯特拉(Dijkstra)引子[摘自:最短路径算法-迪杰斯特拉(Dijkstra)算法 - 知乎 (zhihu.com)]最短路径算法-迪杰斯特拉(Dijkstra)算法迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。它的主要特点是以起始点为中心向外层层扩展(广度优先遍历思想)，直到扩展到终点为止。 基本思想 通过Dijkstra计算图G中的最短路径时，需要指定一个起点D(即从顶点D开始计算)。 此外，引进两个数组S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点D的距离)。 初始时，数组S中只有起点D；数组U中是除起点D之外的顶点，并且数组U中记录各顶点到起点D的距离。如果顶点与起点D不相邻，距离为无穷大。 然后，从数组U中找出路径最短的顶点K，并将其加入到数组S中；同时，从数组U中移除顶点K。接着，更新数组U中的各顶点到起点D的距离。 重复第4步操作，直到遍历完所有顶点。 我的思考图中我用绿色标记已经存入S[]中的节点，黄色标记已经计算过某条路径的节点（不一定是最小值）即U[]中非无穷大的节点, “*”代表 至此,我们凭什么认为C-&gt;D已经找到了最小路径呢？ 证明： C-&gt;D由(N_d + 1)条路径组成 对于C-&gt;E-&gt;D的路径 总路径长度应小于 3 在其他C-&gt;D路径中 若与D相连的路径没有小于 3 的 此处得证 在其他C-&gt;D路径中 若与D相连的路径有小于 3 的 与第一步 选出最短节点操作相悖 该情况不存在 此处得证 同样的问题,我们凭什么认为E-&gt;D已经找到了最小路径呢？ 证明： 对于 E-&gt;C-&gt;D 和 E-&gt;D 已完成对比 大小关系已确定 E-&gt;F-&gt;C 一定大于等于 E-&gt;C 同理 E-&gt;G-&gt;F-&gt;C 一定大于等于 E-&gt;F-&gt;C 大于等于 E-&gt;C 因此E-&gt;为最小路径 还是那个问题,我们凭什么认为F-&gt;E-&gt;D已经找到了最小路径呢？ 证明: F-&gt;C-&gt;E-&gt;D与F-&gt;E-&gt;C-&gt;D均大于等于F-&gt;C-&gt;D和F-&gt;E-&gt;D 对于F-&gt;C-&gt;D和F-&gt;E-&gt;D 已完成比较 后续的步骤: 规律总结 先回到这一步 对于E 非全绿路径路径数一定多于或等于全绿路径 因此非全绿路径的路径长一定大于或等于全绿路径的路径长 而对于全绿路径，每个路径都会在之前的绿节点确认时进行了充分的对比 代码实现参考实现方法:路径规划求最短路径——Dijkstra算法一步一步讲清楚（附代码/可执行）_dijkstra算法步骤-CSDN博客 我使用了一个二维数组weightTable来存储顶点之间的关系另一个二维数组connectionTable来记录各个顶点是否相互连接一个结构体数组DistanceTable来代替传统的S[]和U[]两个数组，用来记录某个顶点是否已经是确定状态（已经达到最小值，也就是上文途中的绿色节点）和当前最小值十六进制数0x7fffffff是int类型的最大值，用于表示无穷大 代码: Dijkstra.hpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#pragma once#include &lt;iostream&gt;using std::cout;using std::cin;using std::endl;class Dijkstra {protected: bool IfLegal(int nodeNumber) { if (nodeNumber &gt;= 0 &amp;&amp; nodeNumber &lt;= nodeAccount - 1) { return true; } return false; } int FindAdjacentNearestNode(int nodeNumber) { int nearestNodeWeight = 0x7fffffff; int nearestNode = -1; int totalWeight; int i; for (i = 0; i &lt; this-&gt;nodeAccount; i++) { //cout &lt;&lt; \"i=\" &lt;&lt; i &lt;&lt; \", nodeNumber=\" &lt;&lt; nodeNumber &lt;&lt; endl; //cin.get(); if (i != nodeNumber &amp;&amp; DistanceTable[i]-&gt;ifConfirm != true) { totalWeight = DistanceTable[nodeNumber]-&gt;shortestDistance + weightTable[nodeNumber][i]; cout &lt;&lt; endl &lt;&lt; \"i=\" &lt;&lt; i &lt;&lt; \", nodeNumber=\" &lt;&lt; nodeNumber &lt;&lt; endl; cout &lt;&lt; \"weightTable[nodeNumber][i]=\" &lt;&lt; weightTable[nodeNumber][i] &lt;&lt; endl; cin.get(); if (connectionTable[nodeNumber][i] &amp;&amp; totalWeight &lt; DistanceTable[i]-&gt;shortestDistance) { DistanceTable[i]-&gt;shortestDistance = totalWeight; } } } //cout &lt;&lt; \"nearestNode=\" &lt;&lt; nearestNode &lt;&lt; endl; //cin.get(); for (int i = 0; i &lt; nodeAccount; i++) { if (DistanceTable[i]-&gt;ifConfirm == false &amp;&amp; DistanceTable[i]-&gt;shortestDistance &lt; nearestNodeWeight) { nearestNodeWeight = DistanceTable[i]-&gt;shortestDistance; nearestNode = i; } } if (nearestNode != -1) { DistanceTable[nearestNode]-&gt;ifConfirm = true; } return nearestNode; }public: Dijkstra(int nodeAccount) { this-&gt;nodeAccount = nodeAccount; weightTable = new int* [this-&gt;nodeAccount]; for (int i = 0; i &lt; this-&gt;nodeAccount; i++) { weightTable[i] = new int[this-&gt;nodeAccount]; for (int j = 0; j &lt; this-&gt;nodeAccount; j++) { weightTable[i][j] = 0x7fffffff; } } connectionTable = new bool* [this-&gt;nodeAccount]; for (int i = 0; i &lt; this-&gt;nodeAccount; i++) { connectionTable[i] = new bool[this-&gt;nodeAccount]; for (int j = 0; j &lt; this-&gt;nodeAccount; j++) { connectionTable[i][j] = false; } } DistanceTable = new NodeAttribute * [this-&gt;nodeAccount]; for (int i = 0; i &lt; this-&gt;nodeAccount; i++) { DistanceTable[i] = new NodeAttribute; DistanceTable[i]-&gt;ifConfirm = false; DistanceTable[i]-&gt;shortestDistance = 0x7fffffff; } } bool BuildLink(int beginNode, int endNode, int weight) { if (IfLegal(beginNode) &amp;&amp; IfLegal(endNode)) { weightTable[beginNode][endNode] = weight; connectionTable[beginNode][endNode] = true; weightTable[endNode][beginNode] = weight; connectionTable[endNode][beginNode] = true; return true; } return false; } bool GetIndex(int rootNode, int* receiveArray, int arraySize) { if (arraySize != this-&gt;nodeAccount) { return false; } DistanceTable[rootNode]-&gt;shortestDistance = 0; DistanceTable[rootNode]-&gt;ifConfirm = true; int nextNode = FindAdjacentNearestNode(rootNode); for (int i = 0; i &lt; nodeAccount; i++) { if (nextNode == -1) { break; } nextNode = FindAdjacentNearestNode(nextNode); } for (int i = 0; i &lt; nodeAccount; i++) { receiveArray[i] = DistanceTable[i]-&gt;shortestDistance; } return true; } ~Dijkstra() { for (int i = 0; i &lt; this-&gt;nodeAccount; i++) { delete[] weightTable[i]; delete[] connectionTable[i]; delete DistanceTable[i]; } delete[] weightTable; delete[] connectionTable; delete[] DistanceTable; }private: int nodeAccount; int** weightTable; bool** connectionTable; struct NodeAttribute { bool ifConfirm; int shortestDistance; }; NodeAttribute** DistanceTable;}; main.cpp 123456789101112131415161718192021222324#include&lt;iostream&gt;#include\"Dijkstra.hpp\"using namespace std;int main() { Dijkstra DijkstraMap(7); DijkstraMap.BuildLink(0, 1, 12); DijkstraMap.BuildLink(0, 5, 16); DijkstraMap.BuildLink(0, 6, 14); DijkstraMap.BuildLink(1, 2, 10); DijkstraMap.BuildLink(1, 5, 7); DijkstraMap.BuildLink(6, 5, 9); DijkstraMap.BuildLink(6, 4, 8); DijkstraMap.BuildLink(5, 2, 6); DijkstraMap.BuildLink(5, 4, 2); DijkstraMap.BuildLink(2, 4, 5); DijkstraMap.BuildLink(2, 3, 3); DijkstraMap.BuildLink(4, 3, 4); int result[7]; DijkstraMap.GetIndex(3, result, 7); for (int i = 0; i &lt; 7; i++) { cout &lt;&lt; result[i] &lt;&lt; endl; }} 以上代码托管于：我的github仓库","categories":[{"name":"CS","slug":"CS","permalink":"http://m1misakamikoto.github.io/categories/CS/"}],"tags":[]},{"title":"位运算符的妙用vol.1","slug":"位运算符的妙用vol-1","date":"2023-10-31T13:25:03.000Z","updated":"2023-10-31T15:38:30.312Z","comments":true,"path":"2023/10/31/位运算符的妙用vol-1/","link":"","permalink":"http://m1misakamikoto.github.io/2023/10/31/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%A6%99%E7%94%A8vol-1/","excerpt":"","text":"位运算符的妙用vol.1&lt;&lt;左移运算符代替乘法先放定义：左移运算符是一个C++中的一种位操作符。用来将一个数的各二进制位全部左移若干位，移动的位数由右操作数指定，右操作数必须是非负值，其右边空出的位用0填补，高位左移溢出则舍弃该高位 举个栗子一是进制数 9 转为二进制是 0000 1001对 0000 1001 进行左移一位的操作后得到 0001 00100001 0010 对应的数就是 18 为什么有这样的规律？将二进制数x2 可以看做对每一位二进制数字x2若该位数字是 0, x2后无变化若该位数字是 1, x2后变为 10最终该数在形式上的变化就是左移了一位 优势运算速度比乘法更快 运算消耗更少 &gt;&gt;右移运算符代替除法同上 |或运算符将偶数+1举个栗子2 | 1 = 3why?:十进制偶数 2 对应二进制数 0010十进制偶数 4 对应二进制数 0100十进制偶数 6 对应二进制数 0110十进制偶数 8 对应二进制数 1000十进制偶数对应的二进制数的个一定是 00 与 1 进行或运算结果是 1反映在十进制数中就是将偶数+1变为奇数 &amp;与运算符将奇数-1举个栗子3 &amp; 0 = 2why?:与或运算符将偶数+1原理类似","categories":[{"name":"CS","slug":"CS","permalink":"http://m1misakamikoto.github.io/categories/CS/"}],"tags":[]},{"title":"前缀和","slug":"前缀和","date":"2023-10-30T13:34:29.000Z","updated":"2023-10-30T14:36:33.162Z","comments":true,"path":"2023/10/30/前缀和/","link":"","permalink":"http://m1misakamikoto.github.io/2023/10/30/%E5%89%8D%E7%BC%80%E5%92%8C/","excerpt":"","text":"前缀和例题输入一个长度为的整数序列，接下来再输入个询问，每个询问输入一对, （左边界和右边界[, ]） 对于每个询问，输出原序列中从第l个数到第r个数的和。 输入格式第一行包含两个整数和。第二行包含个整数，表示整数数列。接下来行，每行包含两个整数和，表示一个询问的区间范围。 输出格式共行，每行输出一个询问的结果。数据范围1≤≤≤,1≤,≤100000,−1000≤数列中元素的值≤1000 输入样例：123455 32 1 3 6 41 21 32 4 输出样例：1233610 前缀和数组举个例子，假设现在有一数组int a[7] = {1,2,3,4,5,6,7}第一位的前缀和就是a[0], 第二位的前缀和就是a[0] + a[1], 以此类推第n位的前缀和就是a[0] + a[1] + … + a[n-1]由此可得一个前缀和数组int frontSUM = {0,1,3,6,10,15,21,28}若此时要求某个区间内[x, y]值的和，那么这个和就等于frontSUM[y] - frontSUM[x - 1]但由于x - 1可能为负值，因此将前缀和数组的第一位设为0 创建前缀和数组引用上述案例的2 1 3 6 4由于frontSUM[n] = frontSUM[n - 1] + an - 1可得： 123456vector frontSUM(1,0);for (int i = 1; i &lt;= 5; i++) { int inputValue; cin &gt;&gt; inputValue; frontSUM.push_back(frontSUM[i - 1] + inputValue); } 测试代码： 123456789101112131415#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main() { vector&lt;int&gt; frontSUM(1,0); for (int i = 1; i &lt;= 5; i++) { int inputValue; cin &gt;&gt; inputValue; frontSUM.push_back(frontSUM[i - 1] + inputValue); } for (int i = 0; i &lt; 6; i++) { cout &lt;&lt; frontSUM[i] &lt;&lt; \" \"; }} 最终题解： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main() { int numAccount = 0; cin &gt;&gt; numAccount; int areaAccount = 0; cin &gt;&gt; areaAccount; vector&lt;int&gt; frontSUM(1,0); for (int i = 1; i &lt;= numAccount; i++) { int inputValue; cin &gt;&gt; inputValue; frontSUM.push_back(frontSUM[i - 1] + inputValue); } struct Area { int leftPoint; int rightPoint; }; vector&lt;Area&gt; areaVector; for (int i = 0; i &lt; areaAccount; i++) { Area areaTemporary; int inputValue; cin &gt;&gt; inputValue; areaTemporary.leftPoint = inputValue; cin &gt;&gt; inputValue; areaTemporary.rightPoint = inputValue; areaVector.push_back(areaTemporary); } for (int i = 0; i &lt; areaAccount; i++) { cout &lt;&lt; frontSUM[areaVector[i].rightPoint] - frontSUM[areaVector[i].leftPoint - 1] &lt;&lt; endl; } return 0;} 参考资料：csdn:前缀和【超详细讲解前缀和】","categories":[{"name":"CS","slug":"CS","permalink":"http://m1misakamikoto.github.io/categories/CS/"}],"tags":[]},{"title":"2023-10-30-LearningRecord","slug":"2023-10-30-LearningRecord","date":"2023-10-30T13:09:19.000Z","updated":"2023-11-01T04:34:35.820Z","comments":true,"path":"2023/10/30/2023-10-30-LearningRecord/","link":"","permalink":"http://m1misakamikoto.github.io/2023/10/30/2023-10-30-LearningRecord/","excerpt":"","text":"刷题Day002 题目一[NOIP2005 普及组] 校门外的树题目描述某校大门外长度为 的马路上有一排树，每两棵相邻的树之间的间隔都是 米。我们可以把马路看成一个数轴，马路的一端在数轴 的位置，另一端在 的位置；数轴上的每个整数点，即 ，都种有一棵树。 由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。 输入格式第一行有两个整数，分别表示马路的长度 和区域的数目 。 接下来 行，每行两个整数 ，表示一个区域的起始点和终止点的坐标。 输出格式输出一行一个整数，表示将这些树都移走后，马路上剩余的树木数量。 样例 #1样例输入 #11234500 3150 300100 200470 471 样例输出 #11298 提示【数据范围】 对于 的数据，保证区域之间没有重合的部分。 对于 的数据，保证 ，，。 【题目来源】 NOIP 2005 普及组第二题 解法一(状态数组)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;//用一个结构体来存储区域的范围struct Volume { int startPoint; int endPoint;};//此函数用于接受输入的数据并存入一个结构体数组 并返回树木数量int collectInput(vector&lt;Volume&gt;&amp; volume) { int Length, areaAccount, leftPoint, rightPoint; scanf(\"%d %d\", &amp;Length, &amp;areaAccount); Volume temp; for (int i = 0; i &lt; areaAccount; i++) { scanf(\"\\n%d %d\", &amp;leftPoint, &amp;rightPoint); temp.startPoint = leftPoint; temp.endPoint = rightPoint; volume.push_back(temp); } return Length + 1;}int main() { //新建一个结构体数组，用于存储要去除树的区域的左右坐标 vector&lt;Volume&gt; volume; //新建一个长度为树的棵树的bool类型数组，用下标代表坐标，true代表此处有树，false代表此处无树 vector&lt;bool&gt; statusArray; int Length = collectInput(volume); //用resize命令申请空间（此时capasity=size，不浪费内存空间） statusArray.resize(Length,true); //砍树:&lt; for (int i = 0; i &lt; volume.size(); i++) { for (int j = volume[i].startPoint; j &lt;= volume[i].endPoint; j++) { statusArray[j] = false; } } //遍历状态数组，统计剩余树的数量 int count = 0; for (int i = 0; i &lt; statusArray.size(); i++) { if (statusArray[i]) { count++; } continue; } //输出 cout &lt;&lt; count; return 0;} 解法二(线段树)：前置知识：[前缀和]前缀和","categories":[{"name":"CS","slug":"CS","permalink":"http://m1misakamikoto.github.io/categories/CS/"}],"tags":[]},{"title":"2023-10-29-LearningRecord","slug":"2023-10-29-LearningRecord","date":"2023-10-29T15:57:00.000Z","updated":"2023-11-01T04:34:43.839Z","comments":true,"path":"2023/10/29/2023-10-29-LearningRecord/","link":"","permalink":"http://m1misakamikoto.github.io/2023/10/29/2023-10-29-LearningRecord/","excerpt":"","text":"刷题Day001 题目一[NOIP2002 普及组] 级数求和题目描述已知：。显然对于任意一个整数 ，当 足够大的时候，。 现给出一个整数 ，要求计算出一个最小的 ，使得 。 输入格式一个正整数 。 输出格式一个正整数 。 样例 #1样例输入 #111 样例输出 #112 提示【数据范围】 对于 的数据，。 【题目来源】 NOIP 2002 普及组第一题 暴力解法：1234567891011int main() { int k; scanf(\"%d\", &amp;k); double SUM = 0; int n = 0; while (SUM &lt; k) { SUM += 1.0 / ++n; } cout &lt;&lt; n; return 0; } 更优的解-数论（调和级数）：▶调和级数讲解已知 欧拉推导过求调和级数有限多项和的表达式为 (约等于)因为题目要求满足的条件是 化简得 因此只需求 并向上取整即可 123456789101112#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;int main() { int k; scanf(\"%d\", &amp;k); int n = exp((double)k - 0.5772156649) + 0.5; cout &lt;&lt; n; return 0;} ps:我不知道为什么 - 1改成 +0.5然后去小数刚好是正确答案 希望有人能解答一下QAQ","categories":[{"name":"CS","slug":"CS","permalink":"http://m1misakamikoto.github.io/categories/CS/"}],"tags":[]}],"categories":[{"name":"CS","slug":"CS","permalink":"http://m1misakamikoto.github.io/categories/CS/"}],"tags":[]}